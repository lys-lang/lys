# Desirable semantics

#### Types

> WIP

```dwl
/**
 * Injected system types, they have no explicit type, it is only a delcaration
 */
type i32 = %stack {lowLevelType="i32"}

/**
 * Type aliases
 */
type int = i32

/**
 * Struct type.
 * Automatically creates a type with the given name and a constructor/alocator
 * for the struct
 */
struct Node(name: string)

// is the same as

type node {
  Node(name: string)
}

/**
 * Every element of the type declaration registers a top level name.
 * So, color is globally available as long with Red Green Blue and Custom
 */
type color {
  Red
  Green
  Blue
  Custom(r: i32, g: i32, b: i32)
}

/**
 * Type values
 * Red is a singleton instance of type Red <: color. That enables us to compare
 * Red == Red in any part of the program
 */
val col: color = Red

/**
 * Type inference
 * the type Red <: color can be inferred
 */
val col = Red

// Custom(r,g,b) is a struct. Equivalent to a case class in scala
// the type of cyan is Custom, and custom extends color
val cyan: Custom = Custom(0, 255, 255)
```

#### Polimorphic types

> WIP

```dwl
/**
 * Polymorphic types:
 * maybe monad
 */
type maybe<T> {
  None
  Some(x: T)
}
```

#### Pattern matching

> WIP

```dwl
/**
 * This function "adds the method" isRed to the type `color``
 */
fun isRed(col: color) =
  match col {
    case Red ->             // type match, in this case is a literal match
      true
    case Custom(r,g,b) ->   // deconstruct
      r == 255 &&
      g == 0 &&
      b == 0
    else ->                 // else
      false
  }

/**
 * Monads
 */
fun getOrElse<T>(value: maybe<T>, fn: fun() -> T): T =
  match value {
    case original is Some(x) ->
      x                     // desonstruct preserving the original value in scope
                            // original type is Some<T>, NOT maybe<T>
    else -> fn()            // else
  }

fun otherScenarios(x: i32) =
  match x {
    case 0 -> 0             // literal pattern matching
    case y if (y > 20) -> y // condition and scoped value
  }
```

#### Partial application leads to type "methods"

> WIP, need to define syntax

We can add methods to a type by setting the first argument of a function with the
desired type

```dwl
// Function application
isRed(Red)                // true
Red.isRed() == isRed(Red) // true

isRed(Custom(1,2,3))      // false
Custom(1,2,3).isRed()     // false

Red == Red                // true
Red != Custom(255, 0, 0)  // true
```

#### Effect handling

> WIP

```dwl
/**
 * This defines a new effect type exc with a single primitive operation, raise
 * with type string â†’ exc a for any a. The raise operation can be used just like
 * any other function
 */
effect exc {
  raise<a>(s : string): a
}

// Type inference will infer the type (int,int) -> exc int propagating the exception effect.
fun div(x: i32, y: i32): <exn> i32 =
  if (y == 0)
    raise("divide by zero")
  else
    x / y


handler XHandler {
  raise(a: string): i32 = 0
}


fun safeDiv(a: i32, b: i32): <total> i32 = {
  with XHandler handle {
    with XHandler handle {
      with XHandler handle {
        div(a, b)
  }}}
}




effect ambient {
  flip(...): bool
}




fun get() = flip(...)

handler X for ambient {
  flip(..., resume: (bool) -> void) {
    resume(true)
    resume(false)
  }
  return x = [x]
}


val res = with X handle get()
```

##

```dwl
type i32 = %stack { lowLevelType="i32" }
type f32 = %stack { lowLevelType="f32" }
type boolean = %stack { lowLevelType="i32" }

type Number {
  Infinity
  NDet
  Real(number: f32)
  Natural(number: i32)
  Complex(real: f32, imaginary: f32)
}

// type Number = Infinity | NDet | Real(f32) | Natural(i32) | Complex(f32, f32)

fun isComplex(number: Number): boolean =
  match number {
    case is Real(_) -> false
    case is Natural(_) -> false
    case is Complex(_, imaginary) -> imaginary != 0.0
    else -> false
  }

fun main() = {
  isComplex(Infinity)
  isComplex(Real(0.0))
  isComplex(Natural(123))
  isComplex(Complex(0.0, 99.1))
}
```

# Tuple

> WIP

Tuples are just a sugar syntax on top of structs.

```dwl
fun main(): (i32, f32) = (1, 1.0)

// equals to

struct Tuple1(_1: i32, _2: f32)
fun main(): Tuple1 = Tuple1(1, 1.0)
```

# Closures

> WIP

Closures work with implicit structs for the "free" variables of the scope.

Here is a brief example of what we want to achieve. This is pseudocode, and doesn't contain any GC code.

```dwl
fun adder(a: i32): fun(i32) -> i32 =
  fun(b: i32): i32 -> a + b

fun main(): void = {
  val x = adder(1) // infers Type<fun(i32) -> i32>

  assert(x(2) == 3)
}

// equals to

val _closure_table_index1 = 1 // auto generated by compiler

struct _closure_context1(
  $funIndex: i32, // WASM table index. Where is the code
  a: i32 // "free" context variable in scope
) extends fun(i32) -> i32

@tableIndex(_closure_table_index1)
fun _closure1(ctx: _closure_context1, b: i32): i32 = {
  ctx.a + b
}

fun adder(a: i32): fun(i32) -> i32 = {
  _closure1(_closure_table_index1, a)
}

fun main(): void = {
  val x = adder(1)

  assert(apply(x, 2) == 3)
}

fun apply(fn: _closure_context1, b: i32): i32 = %wasm {
  (call_indirect fn.$funIndex (get_local b))
}
```
